//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */
export class IConfig {
    /**
     * Returns a valid value for the Authorization header.
     * We return it from local storage
     */
    public constructor(storage : Storage) {
        this.localstorage = storage;
    }
    localstorage: Storage;
    getAuthorization = () => {
      if (this.localstorage) {
        return "Bearer " + this.localstorage.getItem('token');
      }
        return "";
    }
  }
  

export class AuthorizedApiBase {
    private readonly config: IConfig;
  
    protected constructor(config: IConfig) {
      this.config = config;
    }
  
    protected transformOptions = (options: RequestInit): Promise<RequestInit> => {
      options.headers = {
        ...options.headers,
        Authorization: this.config.getAuthorization(),
      };
      return Promise.resolve(options);
    };
  }

export class Client extends AuthorizedApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticationRequest | undefined): Promise<AuthenticationResponseResponse> {
        let url_ = this.baseUrl + "/api/Account/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: Response): Promise<AuthenticationResponseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthenticationResponseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Promise<StringResponse> {
        let url_ = this.baseUrl + "/api/Account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<StringResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param code (optional) 
     * @return Success
     */
    confirmEmail(userId: string | undefined, code: string | undefined): Promise<StringResponse> {
        let url_ = this.baseUrl + "/api/Account/confirm-email?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(response: Response): Promise<StringResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body: ForgotPasswordRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordRequest | undefined): Promise<StringResponse> {
        let url_ = this.baseUrl + "/api/Account/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<StringResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    houseGET(page: number | undefined, pageSize: number | undefined, version: string): Promise<HouseListResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHouseGET(_response);
        });
    }

    protected processHouseGET(response: Response): Promise<HouseListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HouseListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HouseListResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    housePOST(version: string, body: CreateHouseCommand | undefined): Promise<HouseResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHousePOST(_response);
        });
    }

    protected processHousePOST(response: Response): Promise<HouseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HouseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HouseResponse>(null as any);
    }

    /**
     * @return Success
     */
    houseGET2(id: string, version: string): Promise<HouseResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHouseGET2(_response);
        });
    }

    protected processHouseGET2(response: Response): Promise<HouseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HouseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HouseResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    housePUT(id: string, version: string, body: UpdateHouseCommand | undefined): Promise<HouseResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHousePUT(_response);
        });
    }

    protected processHousePUT(response: Response): Promise<HouseResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HouseResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HouseResponse>(null as any);
    }

    /**
     * @return Success
     */
    houseDELETE(id: string, version: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/House/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHouseDELETE(_response);
        });
    }

    protected processHouseDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    temperatures(id: string, version: string): Promise<TemperatureIEnumerableResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House/{Id}/temperatures";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTemperatures(_response);
        });
    }

    protected processTemperatures(response: Response): Promise<TemperatureIEnumerableResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemperatureIEnumerableResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemperatureIEnumerableResponse>(null as any);
    }

    /**
     * @return Success
     */
    humidity(id: string, version: string): Promise<HumidityIEnumerableResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House/{Id}/humidity";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHumidity(_response);
        });
    }

    protected processHumidity(response: Response): Promise<HumidityIEnumerableResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HumidityIEnumerableResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HumidityIEnumerableResponse>(null as any);
    }

    /**
     * @return Success
     */
    sun(id: string, version: string): Promise<SunExposureIEnumerableResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House/{Id}/sun";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSun(_response);
        });
    }

    protected processSun(response: Response): Promise<SunExposureIEnumerableResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SunExposureIEnumerableResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SunExposureIEnumerableResponse>(null as any);
    }

    /**
     * @return Success
     */
    sensors(id: string, version: string): Promise<SensorIEnumerableResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House/{Id}/sensors";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSensors(_response);
        });
    }

    protected processSensors(response: Response): Promise<SensorIEnumerableResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensorIEnumerableResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorIEnumerableResponse>(null as any);
    }

    /**
     * @return Success
     */
    sensors2(id: string, version: string, sensorId: string): Promise<HouseAggregator> {
        let url_ = this.baseUrl + "/api/v{version}/House/{Id}/sensors/{sensorId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (sensorId === undefined || sensorId === null)
            throw new Error("The parameter 'sensorId' must be defined.");
        url_ = url_.replace("{sensorId}", encodeURIComponent("" + sensorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSensors2(_response);
        });
    }

    protected processSensors2(response: Response): Promise<HouseAggregator> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HouseAggregator.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HouseAggregator>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param limitSensors (optional) 
     * @param offsetSensors (optional) 
     * @return Success
     */
    sensors3(page: number | undefined, pageSize: number | undefined, limitSensors: number | undefined, offsetSensors: number | undefined, version: string): Promise<HouseAggregatorIEnumerableResponse> {
        let url_ = this.baseUrl + "/api/v{version}/House/sensors?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (limitSensors === null)
            throw new Error("The parameter 'limitSensors' cannot be null.");
        else if (limitSensors !== undefined)
            url_ += "LimitSensors=" + encodeURIComponent("" + limitSensors) + "&";
        if (offsetSensors === null)
            throw new Error("The parameter 'offsetSensors' cannot be null.");
        else if (offsetSensors !== undefined)
            url_ += "OffsetSensors=" + encodeURIComponent("" + offsetSensors) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSensors3(_response);
        });
    }

    protected processSensors3(response: Response): Promise<HouseAggregatorIEnumerableResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HouseAggregatorIEnumerableResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HouseAggregatorIEnumerableResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    sensorGET(page: number | undefined, pageSize: number | undefined, version: string): Promise<SensorIEnumerableResponse> {
        let url_ = this.baseUrl + "/api/v{version}/Sensor?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSensorGET(_response);
        });
    }

    protected processSensorGET(response: Response): Promise<SensorIEnumerableResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensorIEnumerableResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorIEnumerableResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sensorPOST(version: string, body: CreateSensorCommand | undefined): Promise<SensorResponse> {
        let url_ = this.baseUrl + "/api/v{version}/Sensor";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSensorPOST(_response);
        });
    }

    protected processSensorPOST(response: Response): Promise<SensorResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensorResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorResponse>(null as any);
    }

    /**
     * @return Success
     */
    sensorGET2(id: string, version: string): Promise<SensorResponse> {
        let url_ = this.baseUrl + "/api/v{version}/Sensor/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSensorGET2(_response);
        });
    }

    protected processSensorGET2(response: Response): Promise<SensorResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensorResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorResponse>(null as any);
    }

    /**
     * @return Success
     */
    sensorDELETE(id: string, version: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/Sensor/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSensorDELETE(_response);
        });
    }

    protected processSensorDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sensorPUT(id: string, version: string, body: UpdateSensorCommand | undefined): Promise<SensorResponse> {
        let url_ = this.baseUrl + "/api/v{version}/Sensor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSensorPUT(_response);
        });
    }

    protected processSensorPUT(response: Response): Promise<SensorResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensorResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorResponse>(null as any);
    }
}

export class AuthenticationRequest implements IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthenticationRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    roles?: string[] | undefined;
    isVerified?: boolean;
    jwToken?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.isVerified = _data["isVerified"];
            this.jwToken = _data["jwToken"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["isVerified"] = this.isVerified;
        data["jwToken"] = this.jwToken;
        return data;
    }
}

export interface IAuthenticationResponse {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    roles?: string[] | undefined;
    isVerified?: boolean;
    jwToken?: string | undefined;
}

export class AuthenticationResponseResponse implements IAuthenticationResponseResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: AuthenticationResponse;

    constructor(data?: IAuthenticationResponseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.data = _data["data"] ? AuthenticationResponse.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthenticationResponseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAuthenticationResponseResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: AuthenticationResponse;
}

export class CreateHouseCommand implements ICreateHouseCommand {
    house?: House;

    constructor(data?: ICreateHouseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.house = _data["house"] ? House.fromJS(_data["house"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateHouseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHouseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["house"] = this.house ? this.house.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateHouseCommand {
    house?: House;
}

export class CreateSensorCommand implements ICreateSensorCommand {
    sensor?: Sensor;

    constructor(data?: ICreateSensorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sensor = _data["sensor"] ? Sensor.fromJS(_data["sensor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSensorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSensorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sensor"] = this.sensor ? this.sensor.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateSensorCommand {
    sensor?: Sensor;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string;
}

export class House implements IHouse {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;

    constructor(data?: IHouse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): House {
        data = typeof data === 'object' ? data : {};
        let result = new House();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        return data;
    }
}

export interface IHouse {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
}

export class HouseAggregator implements IHouseAggregator {
    house?: House;
    temperatures?: Temperature[] | undefined;
    humidities?: Humidity[] | undefined;
    sunExposures?: SunExposure[] | undefined;

    constructor(data?: IHouseAggregator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.house = _data["house"] ? House.fromJS(_data["house"]) : <any>undefined;
            if (Array.isArray(_data["temperatures"])) {
                this.temperatures = [] as any;
                for (let item of _data["temperatures"])
                    this.temperatures!.push(Temperature.fromJS(item));
            }
            if (Array.isArray(_data["humidities"])) {
                this.humidities = [] as any;
                for (let item of _data["humidities"])
                    this.humidities!.push(Humidity.fromJS(item));
            }
            if (Array.isArray(_data["sunExposures"])) {
                this.sunExposures = [] as any;
                for (let item of _data["sunExposures"])
                    this.sunExposures!.push(SunExposure.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HouseAggregator {
        data = typeof data === 'object' ? data : {};
        let result = new HouseAggregator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["house"] = this.house ? this.house.toJSON() : <any>undefined;
        if (Array.isArray(this.temperatures)) {
            data["temperatures"] = [];
            for (let item of this.temperatures)
                data["temperatures"].push(item.toJSON());
        }
        if (Array.isArray(this.humidities)) {
            data["humidities"] = [];
            for (let item of this.humidities)
                data["humidities"].push(item.toJSON());
        }
        if (Array.isArray(this.sunExposures)) {
            data["sunExposures"] = [];
            for (let item of this.sunExposures)
                data["sunExposures"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHouseAggregator {
    house?: House;
    temperatures?: Temperature[] | undefined;
    humidities?: Humidity[] | undefined;
    sunExposures?: SunExposure[] | undefined;
}

export class HouseAggregatorIEnumerableResponse implements IHouseAggregatorIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: HouseAggregator[] | undefined;

    constructor(data?: IHouseAggregatorIEnumerableResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(HouseAggregator.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HouseAggregatorIEnumerableResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HouseAggregatorIEnumerableResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHouseAggregatorIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: HouseAggregator[] | undefined;
}

export class HouseListResponse implements IHouseListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: House[] | undefined;

    constructor(data?: IHouseListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(House.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HouseListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HouseListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHouseListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: House[] | undefined;
}

export class HouseResponse implements IHouseResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: House;

    constructor(data?: IHouseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.data = _data["data"] ? House.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HouseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HouseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHouseResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: House;
}

export class Humidity implements IHumidity {
    id?: string;
    createdAt?: Date;
    value?: number;
    recordedAt?: Date;
    houseId?: string;

    constructor(data?: IHumidity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.recordedAt = _data["recordedAt"] ? new Date(_data["recordedAt"].toString()) : <any>undefined;
            this.houseId = _data["houseId"];
        }
    }

    static fromJS(data: any): Humidity {
        data = typeof data === 'object' ? data : {};
        let result = new Humidity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["recordedAt"] = this.recordedAt ? this.recordedAt.toISOString() : <any>undefined;
        data["houseId"] = this.houseId;
        return data;
    }
}

export interface IHumidity {
    id?: string;
    createdAt?: Date;
    value?: number;
    recordedAt?: Date;
    houseId?: string;
}

export class HumidityIEnumerableResponse implements IHumidityIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: Humidity[] | undefined;

    constructor(data?: IHumidityIEnumerableResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Humidity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HumidityIEnumerableResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HumidityIEnumerableResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHumidityIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: Humidity[] | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    firstName!: string;
    lastName!: string;
    email!: string;
    userName!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IRegisterRequest {
    firstName: string;
    lastName: string;
    email: string;
    userName: string;
    password: string;
    confirmPassword: string;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string;
    token!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string;
    token: string;
    password: string;
    confirmPassword: string;
}

export class Sensor implements ISensor {
    id?: string;
    createdAt?: Date;
    type?: SensorType;
    value?: number;
    recordedAt?: Date;
    houseId?: string;

    constructor(data?: ISensor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.value = _data["value"];
            this.recordedAt = _data["recordedAt"] ? new Date(_data["recordedAt"].toString()) : <any>undefined;
            this.houseId = _data["houseId"];
        }
    }

    static fromJS(data: any): Sensor {
        data = typeof data === 'object' ? data : {};
        let result = new Sensor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["recordedAt"] = this.recordedAt ? this.recordedAt.toISOString() : <any>undefined;
        data["houseId"] = this.houseId;
        return data;
    }
}

export interface ISensor {
    id?: string;
    createdAt?: Date;
    type?: SensorType;
    value?: number;
    recordedAt?: Date;
    houseId?: string;
}

export class SensorIEnumerableResponse implements ISensorIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: Sensor[] | undefined;

    constructor(data?: ISensorIEnumerableResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Sensor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SensorIEnumerableResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SensorIEnumerableResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISensorIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: Sensor[] | undefined;
}

export class SensorResponse implements ISensorResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: Sensor;

    constructor(data?: ISensorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.data = _data["data"] ? Sensor.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SensorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SensorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISensorResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: Sensor;
}

export enum SensorType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class StringResponse implements IStringResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: string | undefined;

    constructor(data?: IStringResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): StringResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["data"] = this.data;
        return data;
    }
}

export interface IStringResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: string | undefined;
}

export class SunExposure implements ISunExposure {
    id?: string;
    createdAt?: Date;
    value?: number;
    recordedAt?: Date;
    houseId?: string;

    constructor(data?: ISunExposure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.recordedAt = _data["recordedAt"] ? new Date(_data["recordedAt"].toString()) : <any>undefined;
            this.houseId = _data["houseId"];
        }
    }

    static fromJS(data: any): SunExposure {
        data = typeof data === 'object' ? data : {};
        let result = new SunExposure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["recordedAt"] = this.recordedAt ? this.recordedAt.toISOString() : <any>undefined;
        data["houseId"] = this.houseId;
        return data;
    }
}

export interface ISunExposure {
    id?: string;
    createdAt?: Date;
    value?: number;
    recordedAt?: Date;
    houseId?: string;
}

export class SunExposureIEnumerableResponse implements ISunExposureIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: SunExposure[] | undefined;

    constructor(data?: ISunExposureIEnumerableResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SunExposure.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SunExposureIEnumerableResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SunExposureIEnumerableResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISunExposureIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: SunExposure[] | undefined;
}

export class Temperature implements ITemperature {
    id?: string;
    createdAt?: Date;
    value?: number;
    recordedAt?: Date;
    houseId?: string;

    constructor(data?: ITemperature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.recordedAt = _data["recordedAt"] ? new Date(_data["recordedAt"].toString()) : <any>undefined;
            this.houseId = _data["houseId"];
        }
    }

    static fromJS(data: any): Temperature {
        data = typeof data === 'object' ? data : {};
        let result = new Temperature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["recordedAt"] = this.recordedAt ? this.recordedAt.toISOString() : <any>undefined;
        data["houseId"] = this.houseId;
        return data;
    }
}

export interface ITemperature {
    id?: string;
    createdAt?: Date;
    value?: number;
    recordedAt?: Date;
    houseId?: string;
}

export class TemperatureIEnumerableResponse implements ITemperatureIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: Temperature[] | undefined;

    constructor(data?: ITemperatureIEnumerableResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Temperature.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemperatureIEnumerableResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemperatureIEnumerableResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITemperatureIEnumerableResponse {
    succeeded?: boolean;
    message?: string | undefined;
    errors?: string[] | undefined;
    data?: Temperature[] | undefined;
}

export class UpdateHouseCommand implements IUpdateHouseCommand {
    id?: string;
    house?: HouseAggregator;

    constructor(data?: IUpdateHouseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.house = _data["house"] ? HouseAggregator.fromJS(_data["house"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateHouseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHouseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["house"] = this.house ? this.house.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateHouseCommand {
    id?: string;
    house?: HouseAggregator;
}

export class UpdateSensorCommand implements IUpdateSensorCommand {
    id?: string;
    sensor?: Sensor;

    constructor(data?: IUpdateSensorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sensor = _data["sensor"] ? Sensor.fromJS(_data["sensor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateSensorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSensorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sensor"] = this.sensor ? this.sensor.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateSensorCommand {
    id?: string;
    sensor?: Sensor;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

